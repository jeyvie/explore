# 接口

接口也是种特殊的类型标注

## 简介

> One of TypeScript’s core principles is that type-checking focuses on **the shape that values have**. This is sometimes called “duck typing” or “structural subtyping”. In TypeScript, interfaces fill **the role of naming these types**, and are a powerful way of **defining contracts** within your code as well as contracts with code outside of your project.

1. `ts` 类型检测的是 `形`， 结构： `鸭子类型`
2. `interface` 是类型的名称
3. `interface` 是种用来沟通`约定`的工具

## 接口

1. 简单的例子

    ```
    function printLabel(labelledObj: { label: string }) {
        console.log(labelledObj.label);
    }
    
    let myObj = {size: 10, label: "Size 10 Object"};
    printLabel(myObj);
    ```

    
    函数 `printLabel` 的参数 `labelledObj`后的冒号 `:` 跟的`{ label: string }` 就是个接口。这个接口表明，入参里必须有 `label` 字段，且类型得是 `string`。
    
    其中，接口值检验标明的属性类型，

    1. 对多余的属性和属性的顺序都没有要求;
    2. 虽然入参里多了 `size`, 也没关系。
    
    用接口的方式是：
    
    ```
    interface LabelledValue {
        label: string;
    }
    
    function printLabel(labelledObj: LabelledValue) {
        console.log(labelledObj.label);
    }
    
    let myObj = {size: 10, label: "Size 10 Object"};
    printLabel(myObj);
    ```

2. 可选属性

    属性名后跟 `?` 标明该属性可选。
    
    `可选属性` 除了
    
    1. 标明属性可选之外
    2. 还可用于防止拼写错误

    **但这也意味着，多传进来的属性，是无用的**
    
    ```
    interface SquareConfig {
        color?: string;
        width?: number;
    }

    function createSquare(config: SquareConfig): { color: string; area: number } {
        let newSquare = {color: "white", area: 100};
        if (config.clor) {
            // Error: Property 'clor' does not exist on type 'SquareConfig'
            newSquare.color = config.clor;
        }
        if (config.width) {
            newSquare.area = config.width * config.width;
        }
        return newSquare;
    }

    let mySquare = createSquare({color: "black"});

    ```


